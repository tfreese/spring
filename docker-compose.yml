# docker network create my-fancy-network
# docker run -i -t --name container1 --net=my-fancy-network --net-alias=container1 ubuntu:trusty /bin/bash
# docker run -i -t --name container2 --net=my-fancy-network --net-alias=container2 ubuntu:trusty /bin/bash
# Die Container können sich nun untereinander über ihre Aliasnamen ansprechen (HTTP://container1), keine IPs verwenden !

# docker-compose build
# docker-compose up -d --scale spring-microservice=3
# docker-compose ps
# docker logs ID/NAME;
# docker-compose down

# for disk in {1..1000}; do curl localhost/service/sysdate; echo ""; sleep 1; done;
#
# multi-stage builds: https://docs.docker.com/develop/develop-images/multistage-build/

version: '3'
services:

    spring-boot-admin:
        container_name: spring-boot-admin
        build:
            context: ./spring-boot-admin
            dockerfile: Dockerfile
        image: spring-boot-admin:latest
        #image: localhost:5000/spring-boot-admin:latest
        #restart: always
        environment:
            SPRING_APPLICATION_JSON:
                '{
         "spring":
         {
           "boot":
           {
             "client":
             {
               "prefer-ip": "true"
             }
           }
         }
       }'
        ports:
            - 9000:9000
        networks:
            main:
                aliases:
                    - admin                    
        # https://docs.docker.com/compose/compose-file/#resources                    
        deploy:
            resources:
                limits:
                    cpus: "0.5"
                    memory: 128M
                reservations:
                    cpus: "0.25"
                    memory: 64M                    

    spring-eureka:
        container_name: spring-eureka
        build:
            context: ./spring-eureka
            dockerfile: Dockerfile
        image: spring-eureka:latest
        #image: localhost:5000/spring-eureka:latest
        #restart: always
        environment:
            SPRING_APPLICATION_JSON:
                '{
         "eureka":
         {
           "client":
           {
             "serviceUrl":
             {
               "defaultZone": "http://eureka:9001/eureka"
             }
           }
         }
        }'
        ports:
            - 9001:9001
        networks:
            main:
                aliases:
                    - eureka
        # https://docs.docker.com/compose/compose-file/#resources                    
        deploy:
            resources:
                limits:
                    cpus: "0.5"
                    memory: 128M
                reservations:
                    cpus: "0.25"
                    memory: 64M                    

    spring-microservice:
        build:
            context: ./spring-microservice
            dockerfile: Dockerfile
        image: spring-microservice:latest
        #image: localhost:5000/spring-microservice:latest
        #restart: always
        environment:
            SPRING_APPLICATION_JSON:
                '{
        "eureka":
        {
          "client":
          {
            "serviceUrl":
            {
              "defaultZone": "http://eureka:9001/eureka"
            }
          },
          "instance":
          {
            "preferIpAddress": "true"
          }
        },
        "spring":
        {
          "boot":
          {
            "admin":
            {
              "client":
              {
                "instance":
                {
                  "prefer-ip": "true"
                },   
                "url": "http://admin:9000"
              }
            }
          }
        }
        }'
        #- JAVA_OPTS="-Dserver.port=0"
        depends_on:
            - spring-boot-admin
            - spring-eureka
        networks:
            main:
        # https://docs.docker.com/compose/compose-file/#resources                    
        deploy:
            resources:
                limits:
                    cpus: "1"
                    memory: 256M
                reservations:
                    cpus: "0.5"
                    memory: 128M            

    # export HAPROXY_IMAGE=haproxy:1.9.8-alpine
    loadbalancer:
        image: "${HAPROXY_IMAGE:-dockercloud/haproxy:latest}"
        #restart: always
        volumes:
            - /var/run/docker.sock:/var/run/docker.sock
        ports:
            - 80:80
        networks:
            - main
        links:
            - spring-microservice

# Network-Bridge: Zugriff auf Services die auf dem Host 192.168.155.1 laufen.
# docker network create -d bridge --subnet 192.168.155.0/24 --gateway 192.168.155.1 dockernet;
# docker network rm dockernet;
#
# localhost im Docker-Netz finden: ifconfig | grep -E "([0-9]{1,3}\.){3}[0-9]{1,3}" | grep -v 127.0.0.1 | awk '{ print $2 }' | cut -f2 -d: | head -n1;
networks:
    main:
    #default:
    #driver: bridge
    #dockernet:
    #external: true
