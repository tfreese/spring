# docker network create my-fancy-network
# docker run -i -t --name container1 --net=my-fancy-network --net-alias=container1 ubuntu:trusty /bin/bash
# docker run -i -t --name container2 --net=my-fancy-network --net-alias=container2 ubuntu:trusty /bin/bash
# Die Container können sich nun untereinander über ihre Aliasnamen ansprechen (HTTP://container1), keine IPs verwenden !

# docker-compose build;
# docker-compose up --build;
# docker-compose up [-d] -- build --scale spring-microservice=3;
# docker-compose ps;
# docker logs ID/NAME;
# docker-compose down

# for disk in {1..1000}; do curl localhost/service/sysdate; echo ""; sleep 1; done;
#
# multi-stage builds: https://docs.docker.com/develop/develop-images/multistage-build/
# https://github.com/benwilcock/spring-cloud-gateway-demo

version: '3'
services:

    spring-boot-admin:
        container_name: spring-boot-admin
        build:
            context: ./spring-boot-admin
            dockerfile: Dockerfile
        image: spring-boot-admin:latest
        ports:
            - 9000:9000                                  

    spring-eureka:
        container_name: spring-eureka
        build:
            context: ./spring-eureka
            dockerfile: Dockerfile
        image: spring-eureka:latests
        ports:
            - 8761:8761                    

    spring-microservice:
        build:
            context: ./spring-microservice
            dockerfile: Dockerfile
        image: spring-microservice:latest
        environment:
            - JAVA_OPTS=
                -DEUREKA_SERVER=http://spring-eureka:8761/eureka
                -DADMIN_SERVER=http://spring-boot-admin:9000
        depends_on:
            - spring-boot-admin
            - spring-eureka          

    loadbalancer:
        image: "${HAPROXY_IMAGE:-dockercloud/haproxy:latest}"
        volumes:
            - /var/run/docker.sock:/var/run/docker.sock
        ports:
            - 8081:80
        depends_on:
            - spring-microservice
        links:
            - spring-microservice

